This component relied heavily on the backend. I originally thought of integrating this artifact during CS340 course. It is imperative that I highlight a cloud-based NoSQL database in today’s market because you must have the ability to create a modern scalable backend system in today’s industry. My backend is built in Google Firebase. It stores and manages my inventory data in real time. The system also manages my user authentication and keeps a persistent data layer for the apps functionality. 


Some specific components that I integrated to highlight my skills are in my FirestortInventoryRepository.kt file. Here I demonstrate a full CRUD suite with real time listening functionality. I kept my code clean and readable with all the CRUD components clearly defined. In MainActivity I showed my skills as it pertains to security. I created a user sign in, account creating, and password reset functionality that flows through Firebase. This is a main function element of any production application. I infused Coroutines(Suspend and Wait) throughout my application to manage the network database. This ensures the App will not freeze while waiting for data and remains responsive. These functions meet my goals of setting up authentication and security rules within a cloud database. 


This artifact really stretched my learning. I really had to learn to separate my concerns when developing software architecture. FirestorInventoryRepository is completely its own entity, and I could swap out the database without touching the UI code. I learned about levering coroutines to prevent memory leaks by managing the lifecycle of real time data. The biggest challenge was reading the real time updates correctly. I needed to implement onFocusChangeListener to ensure the data was not updated until the user was finished with the field. This helps with saving resources with fewer database writes.


On the client side I utilized repo.listen to establish a connection with the database. This ensured whenever an item was added, changed, or removed, the database was actively receiving that information to update the database. I utilized DiffUtil to calculate the differences between the old and new database. This ensured that the recycler view did not re-render until the field fully changed. All the buttons triggered calls within the suspend function. These functions would be launched in a Coroutine (lifecycleScope) to work in the background to ensure responsiveness. 
